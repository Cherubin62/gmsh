<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Gmsh tutorial</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<H1>Contents</H1>
<OL>
  <LI><A HREF="#file1">README</A>
  <LI><A HREF="#file2">t1.geo</A>
  <LI><A HREF="#file3">t2.geo</A>
  <LI><A HREF="#file4">t3.geo</A>
  <LI><A HREF="#file5">t4.geo</A>
  <LI><A HREF="#file6">t5.geo</A>
  <LI><A HREF="#file7">t6.geo</A>
  <LI><A HREF="#file8">t7.geo</A>
  <LI><A HREF="#file9">t8.geo</A>
  <LI><A HREF="#file10">t9.geo</A>
</OL>
<HR>
<A NAME="file1">
<H1>README 1/10</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
$Id: tutorial.html,v 1.34 2002-09-11 18:30:11 geuzaine Exp $

Here are the examples in the Gmsh tutorial. These examples are
commented (both C and C++-style comments can be used in Gmsh input
files) and should introduce new features gradually, starting with
t1.geo.

[NOTE: This tutorial does not explain the mesh and post-processing
file formats. See the FORMATS file for this.]

There are two ways to actually run these examples with Gmsh. (The
operations to run Gmsh may vary according to your operating system. In
the folowing examples, we will assume that you're working with a
UNIX-like shell.) The first working mode of Gmsh is the interactive
graphical mode. To launch Gmsh in interactive mode, just type

&gt; gmsh

at the prompt on the command line. This will open two windows: the
graphic window (with a status bar at the bottom) and the menu window
(with a menu bar and some context dependent buttons). To open the
first tutorial file, select the 'File-&gt;Open' menu, and choose 't1.geo'
in the input field. To perform the mesh generation, go to the mesh
module (by selecting 'Mesh' in the module menu) and choose the
required dimension in the context-dependent buttons ('1D' will mesh
all the curves; '2D' will mesh all the surfaces ---as well as all the
curves if '1D' was not called before; '3D' will mesh all the volumes
---and all the surfaces if '2D' was not called before). To save the
resulting mesh in the current mesh format, choose 'Save' in the
context-dependent buttons, or select the appropriate format with the
'File-&gt;Save as' menu. The default mesh file name is based on the name
of the first input file on the command line (or 'unnamed' if there
wasn't any input file given), with an appended extension depending on
the mesh format.

[NOTE: Nearly all the interactive commands have shortcuts. Select
'Help-&gt;Shortcuts' in the menu bar to learn about these shortcuts.]

Instead of opening the tutorial with the 'File-&gt;Open' menu, it is
often more convenient to put the file name on the command line, for
example with:

&gt; gmsh t1.geo

[NOTE: The '.geo' extension can also be omitted.]

[NOTE: Even if it is often handy to define the variables and the
points directly in the input files (you may use any text editor for
this purpose, e.g. Wordpad on Windows, or Emacs on Unix), it is almost
always more simple to define the curves, the surfaces and the volumes
interactively. To do so, just follow the context dependent buttons in
the Geometry module. For example, to create a spline, select
'Geometry' in the module menu, and then select 'Elementary, Add, New,
Spline'. You will then be asked (in the status bar of the graphic
window) to select a list of points, and to click 'e' to finish the
selection (or 'q' to abort it). Once the interactive command is
completed, a string is automatically added at the end of the currently
opened project file.]

The second operating mode for Gmsh is the non-interactive mode. In
this mode, there is no graphical user interface, and all operations
are performed without any interaction. To mesh the first tutorial in
non-interactive mode, just type:

&gt; gmsh t1.geo -2

To mesh the same example, but with the backgound mesh available in the
file 'bgmesh.pos', just type:

&gt; gmsh t1.geo -2 -bgm bgmesh.pos

[NOTE: You should read the notes in the file 'bgmesh.pos' if you
intend to use background meshes.]

Several files can be loaded simultaneously in Gmsh. The first one
defines the project, while the others are appended (&quot;merged&quot;) to this
project. You can merge such files with the 'File-&gt;Merge' menu, or by
directly specifying the names of the files on the command line. This
is most useful for post-processing purposes. For example, to merge the
post-processing views contained in the files 'view1.pos' and
'view2.pos' together with the first tutorial 't1.geo', you can type
the following command:

&gt; gmsh t1.geo view1.pos view2.pos

In the Post-Processing module (select 'Post_Processing' in the module
menu), two view buttons will appear, respectively labeled &quot;a scalar
map&quot; and &quot;a vector map&quot;. A left mouse click toggles the visibility of
the selected view. A right mouse click provides access to the view's
options. If you want the modifications made to one view to affect also
all the other views, select the 'Apply next changes to all views' or
'Force same options for all views' option in the
'Options-&gt;Post-processing' menu.

[NOTE: All the options specified interactively can also be directly
specified in the ascii input files. All available options, with their
current values, can be saved into a file by selecting 'File-&gt;Save
as-&gt;Gmsh options', or simply viewed by pressing the '?' button in the
status bar. To save the current options as your default preferences
for all future Gmsh sessions, use the 'Options-&gt;Save options now'
menu.]


OK, that's all, folks. Enjoy the tutorial.

</PRE>
<HR>
<A NAME="file2">
<H1>t1.geo 2/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 1
 * 
 *  Variables, Elementary entities (Points, Lines, Surfaces), Physical
 *  entities (Points, Lines, Surfaces), Background mesh
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// All geometry description in Gmsh is made by means of a special
</FONT></I><I><FONT COLOR="#B22222">// language (looking somewhat similar to C). The simplest construction
</FONT></I><I><FONT COLOR="#B22222">// of this language is the 'affectation'. 
</FONT></I>
<I><FONT COLOR="#B22222">// The following command (all commands end with a semi colon) defines
</FONT></I><I><FONT COLOR="#B22222">// a variable called 'lc' and affects the value 0.007 to 'lc':
</FONT></I>
lc = 0.007 ;

<I><FONT COLOR="#B22222">// This newly created variable can be used to define the first Gmsh
</FONT></I><I><FONT COLOR="#B22222">// elementary entity, a 'Point'. A Point is defined by a list of four
</FONT></I><I><FONT COLOR="#B22222">// numbers: its three coordinates (x, y and z), and a characteristic
</FONT></I><I><FONT COLOR="#B22222">// length which sets the target mesh size at the point:
</FONT></I>
Point(1) = {0,  0,  0, 9.e-1 * lc} ;

<I><FONT COLOR="#B22222">// The mesh size is defined as the length of the segments for lines,
</FONT></I><I><FONT COLOR="#B22222">// the radii of the circumscribed circles for triangles and the radii
</FONT></I><I><FONT COLOR="#B22222">// of the circumscribed spheres for tetrahedra, respectively. The
</FONT></I><I><FONT COLOR="#B22222">// actual distribution of the mesh sizes is obtained by interpolation
</FONT></I><I><FONT COLOR="#B22222">// of the characteristic lengths prescribed at the points. There are
</FONT></I><I><FONT COLOR="#B22222">// also other possibilities to specify characteristic lengths:
</FONT></I><I><FONT COLOR="#B22222">// attractors (see t7.geo) and background meshes (see bgmesh.pos).
</FONT></I>
<I><FONT COLOR="#B22222">// As can be seen in the previous definition, more complex expressions
</FONT></I><I><FONT COLOR="#B22222">// can be constructed from variables. Here, the product of the
</FONT></I><I><FONT COLOR="#B22222">// variable 'lc' by the constant 9.e-1 is given as the fourth argument
</FONT></I><I><FONT COLOR="#B22222">// of the list defining the point.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The following general syntax rule is applied for the definition of
</FONT></I><I><FONT COLOR="#B22222">// all geometrical entities:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    &quot;If a number defines a new entity, it is enclosed between
</FONT></I><I><FONT COLOR="#B22222">//    parentheses. If a number refers to a previously defined entity,
</FONT></I><I><FONT COLOR="#B22222">//    it is enclosed between braces.&quot;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Three additional points are then defined:
</FONT></I>
Point(2) = {.1, 0,  0, lc} ;
Point(3) = {.1, .3, 0, lc} ;
Point(4) = {0,  .3, 0, lc} ;

<I><FONT COLOR="#B22222">// The second elementary geometrical entity in Gmsh is the
</FONT></I><I><FONT COLOR="#B22222">// curve. Amongst curves, straight lines are the simplest. A straight
</FONT></I><I><FONT COLOR="#B22222">// line is defined by a list of point numbers. For example, line 1
</FONT></I><I><FONT COLOR="#B22222">// starts at point 1 and ends at point 2:
</FONT></I>
Line(1) = {1,2} ;
Line(2) = {3,2} ;
Line(3) = {3,4} ;
Line(4) = {4,1} ;

<I><FONT COLOR="#B22222">// The third elementary entity is the surface. In order to define a
</FONT></I><I><FONT COLOR="#B22222">// simple rectangular surface from the four lines defined above, a
</FONT></I><I><FONT COLOR="#B22222">// line loop has first to be defined. A line loop is a list of
</FONT></I><I><FONT COLOR="#B22222">// connected lines, a sign being associated with each line (depending
</FONT></I><I><FONT COLOR="#B22222">// on the orientation of the line).
</FONT></I>
Line Loop(5) = {4,1,-2,3} ;

<I><FONT COLOR="#B22222">// The surface is then defined as a list of line loops (only one
</FONT></I><I><FONT COLOR="#B22222">// here):
</FONT></I>
Plane Surface(6) = {5} ;

<I><FONT COLOR="#B22222">// At this level, Gmsh knows everything to display the rectangular
</FONT></I><I><FONT COLOR="#B22222">// surface 6 and to mesh it. But a supplementary step is needed in
</FONT></I><I><FONT COLOR="#B22222">// order to assign region numbers to the various elements in the mesh
</FONT></I><I><FONT COLOR="#B22222">// (the points, the lines and the triangles discretizing points 1 to
</FONT></I><I><FONT COLOR="#B22222">// 4, lines 1 to 4 and surface 6). This is achieved by the definition
</FONT></I><I><FONT COLOR="#B22222">// of Physical entities. Physical entities will group elements
</FONT></I><I><FONT COLOR="#B22222">// belonging to several elementary entities by giving them a common
</FONT></I><I><FONT COLOR="#B22222">// number (a region number), and specifying their orientation.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// For example, the two points 1 and 2 can be grouped into the
</FONT></I><I><FONT COLOR="#B22222">// physical entity 1:
</FONT></I>
Physical Point(1) = {1,2} ;

<I><FONT COLOR="#B22222">// Consequently, two punctual elements will be saved in the output
</FONT></I><I><FONT COLOR="#B22222">// files, both with the region number 1. The mechanism is identical
</FONT></I><I><FONT COLOR="#B22222">// for line or surface elements:
</FONT></I>
Physical Line(10) = {1,2,4} ;
MySurface = 100;
Physical Surface(MySurface) = {6} ;

<I><FONT COLOR="#B22222">// All the line elements which will be created during the mesh of
</FONT></I><I><FONT COLOR="#B22222">// lines 1, 2 and 4 will be saved in the output file with the region
</FONT></I><I><FONT COLOR="#B22222">// number 10; and all the triangular elements resulting from the
</FONT></I><I><FONT COLOR="#B22222">// discretization of surface 6 will be given the region number 100.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// If no physical groups are defined, all the elements in the mesh are
</FONT></I><I><FONT COLOR="#B22222">// directly saved with their default orientation and with a region
</FONT></I><I><FONT COLOR="#B22222">// number equal to their elementary region number. For a description
</FONT></I><I><FONT COLOR="#B22222">// of the mesh and post-processing formats, see the FORMATS file.
</FONT></I></PRE>
<HR>
<A NAME="file3">
<H1>t2.geo 3/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 2
 * 
 *  Includes, Geometrical transformations, Extruded geometries,
 *  Elementary entities (Volumes), Physical entities (Volumes)
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// The first tutorial file will serve as a basis to construct this
</FONT></I><I><FONT COLOR="#B22222">// one. It can be included with:
</FONT></I>
Include &quot;t1.geo&quot; ;

<I><FONT COLOR="#B22222">// There are several possibilities to build a more complex geometry
</FONT></I><I><FONT COLOR="#B22222">// from the one previously defined in 't1.geo'.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// New points, lines and surfaces can first be directly defined in the
</FONT></I><I><FONT COLOR="#B22222">// same way as in 't1.geo':
</FONT></I>
Point(5) = {0, .4, 0, lc} ;
Line(5) = {4, 5} ;

<I><FONT COLOR="#B22222">// But Gmsh also provides geometrical transformation mechanisms to
</FONT></I><I><FONT COLOR="#B22222">// move (translate, rotate, ...), add (translate, rotate, ...) or
</FONT></I><I><FONT COLOR="#B22222">// extrude (translate, rotate) elementary geometrical entities. For
</FONT></I><I><FONT COLOR="#B22222">// example, the point 3 can be moved by 0.05 units on the left with:
</FONT></I>
Translate {-0.05,0,0} { Point{3} ; }

<I><FONT COLOR="#B22222">// The resulting point can also be duplicated and translated by 0.1
</FONT></I><I><FONT COLOR="#B22222">// along the y axis:
</FONT></I>
Translate {0,0.1,0} { Duplicata{ Point{3} ; } }

<I><FONT COLOR="#B22222">// Of course, translation, rotation and extrusion commands not only
</FONT></I><I><FONT COLOR="#B22222">// apply to points, but also to lines and surfaces. The following
</FONT></I><I><FONT COLOR="#B22222">// command extrudes surface 6 defined in 't1.geo', as well as a new
</FONT></I><I><FONT COLOR="#B22222">// surface 11, along the z axis by 'h':
</FONT></I>
h = 0.12 ;
Extrude Surface { 6, {0, 0, h} } ;

Line(7) = {3, 6} ; Line(8) = {6,5} ; Line Loop(10) = {5,-8,-7,3};

Plane Surface(11) = {10};

Extrude Surface { 11, {0, 0, h} } ;

<I><FONT COLOR="#B22222">// All these geometrical transformations automatically generate new
</FONT></I><I><FONT COLOR="#B22222">// elementary entities. The following commands permit to specify
</FONT></I><I><FONT COLOR="#B22222">// manually a characteristic length for some of the automatically
</FONT></I><I><FONT COLOR="#B22222">// created points:
</FONT></I>
Characteristic Length{6,22,2,3,16,12} = lc * 2 ;

<I><FONT COLOR="#B22222">// If the transformation tools are handy to create complex geometries,
</FONT></I><I><FONT COLOR="#B22222">// it is sometimes useful to generate the flat geometry, consisting
</FONT></I><I><FONT COLOR="#B22222">// only of the explicit list elementary entities. This can be achieved
</FONT></I><I><FONT COLOR="#B22222">// by selecting the 'File-&gt;Save as-&gt;Gmsh unrolled geometry' menu or by
</FONT></I><I><FONT COLOR="#B22222">// typing
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// &gt; gmsh t2.geo -0
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// on the command line.
</FONT></I>
<I><FONT COLOR="#B22222">// Volumes are the fourth type of elementary entities in Gmsh. In the
</FONT></I><I><FONT COLOR="#B22222">// same way one defines line loops to build surfaces, one has to
</FONT></I><I><FONT COLOR="#B22222">// define surface loops to build volumes. The following volumes are
</FONT></I><I><FONT COLOR="#B22222">// very simple, without holes (and thus consist of only one surface
</FONT></I><I><FONT COLOR="#B22222">// loop):
</FONT></I>
Surface Loop(145) = {121,11,131,135,139,144};
Volume(146) = {145};

Surface Loop(146) = {121,6,109,113,117,122};
Volume(147) = {146};

<I><FONT COLOR="#B22222">// To save all volumic (tetrahedral) elements of volume 146 and 147
</FONT></I><I><FONT COLOR="#B22222">// with the associate region number 1, a Physical Volume must be
</FONT></I><I><FONT COLOR="#B22222">// defined:
</FONT></I>
Physical Volume (1) = {146,147} ;

<I><FONT COLOR="#B22222">// Congratulations! You've created your first fully unstructured
</FONT></I><I><FONT COLOR="#B22222">// tetrahedral 3D mesh!
</FONT></I></PRE>
<HR>
<A NAME="file4">
<H1>t3.geo 4/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 3
 * 
 *  Extruded meshes, Options
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// Again, the first tutorial example is included:
</FONT></I>
Include &quot;t1.geo&quot; ;

<I><FONT COLOR="#B22222">// As in 't2.geo', an extrusion along the z axis will be performed:
</FONT></I>
h = 0.1 ;

<I><FONT COLOR="#B22222">// But contrary to 't2.geo', not only the geometry will be extruded,
</FONT></I><I><FONT COLOR="#B22222">// but also the 2D mesh. This is done with the same Extrude command,
</FONT></I><I><FONT COLOR="#B22222">// but by specifying the number of layers (here, there will be four
</FONT></I><I><FONT COLOR="#B22222">// layers, of respectively 8, 4, 2 and 1 elements in depth), with
</FONT></I><I><FONT COLOR="#B22222">// volume numbers 9000 to 9003 and respective heights equal to h/4:
</FONT></I>
Extrude Surface { 6, {0,0,h} } { 
  Layers { {8,4,2,1}, {9000:9003}, {0.25,0.5,0.75,1} } ; 
} ;

<I><FONT COLOR="#B22222">// The extrusion can also performed with a rotation instead of a
</FONT></I><I><FONT COLOR="#B22222">// translation, and the resulting mesh can be recombined into prisms
</FONT></I><I><FONT COLOR="#B22222">// (wedges) if the surface elements are triangles, or hexahedra if the
</FONT></I><I><FONT COLOR="#B22222">// surface elements are quadrangles. All rotations are specified by an
</FONT></I><I><FONT COLOR="#B22222">// axis direction ({0,1,0}), an axis point ({-0.1,0,0.1}) and a
</FONT></I><I><FONT COLOR="#B22222">// rotation angle (-Pi/2):
</FONT></I>
Extrude Surface { 122, {0,1,0} , {-0.1,0,0.1} , -Pi/2 } { 
  Recombine ; Layers { 7, 9004, 1 } ; 
};

<I><FONT COLOR="#B22222">// A translation ({-2*h,0,0}) and a rotation ({1,0,0} , {0,0.15,0.25},
</FONT></I><I><FONT COLOR="#B22222">// Pi/2) can be combined:
</FONT></I>
Extrude Surface {news-1, {-2*h,0,0}, {1,0,0} , {0,0.15,0.25} , Pi/2}{ 
  Layers {10,9004,1}; Recombine; 
};

Physical Volume(101) = {9000:9004};

<I><FONT COLOR="#B22222">// All interactive options can also be set directly in the input file.
</FONT></I><I><FONT COLOR="#B22222">// For example, the following lines define a global characteristic
</FONT></I><I><FONT COLOR="#B22222">// length factor, redefine some background colors, disable the display
</FONT></I><I><FONT COLOR="#B22222">// of the axes, and select an initial viewpoint in XYZ mode (disabling
</FONT></I><I><FONT COLOR="#B22222">// the interactive trackball-like rotation mode):
</FONT></I>
Mesh.CharacteristicLengthFactor = 4;
General.Color.Background = {120,120,120};
General.Color.Foreground = {255,255,255};
General.Color.Text = White;
Geometry.Color.Points = Orange;
General.Axes = 0;
General.Trackball = 0;
General.RotationX = 10;
General.RotationY = 70;
General.TranslationX = -0.2;

<I><FONT COLOR="#B22222">// Note: all colors can be defined literally or numerically, i.e.
</FONT></I><I><FONT COLOR="#B22222">// 'General.Color.Background = Red' is equivalent to
</FONT></I><I><FONT COLOR="#B22222">// 'General.Color.Background = {255,0,0}'. As with user-defined
</FONT></I><I><FONT COLOR="#B22222">// variables, the options can be used either as right hand or left
</FONT></I><I><FONT COLOR="#B22222">// hand sides, so that
</FONT></I>
Geometry.Color.Surfaces = Geometry.Color.Points;

<I><FONT COLOR="#B22222">// will assign the color of the surfaces in the geometry to the same
</FONT></I><I><FONT COLOR="#B22222">// color as the points.
</FONT></I>
<I><FONT COLOR="#B22222">// A click on the '?'  button in the status bar of the graphic window
</FONT></I><I><FONT COLOR="#B22222">// will dump all current options to the terminal. To save all
</FONT></I><I><FONT COLOR="#B22222">// available options to a file, use the 'File-&gt;Save as-&gt;Gmsh options'
</FONT></I><I><FONT COLOR="#B22222">// menu. To save the current options as the default options for all
</FONT></I><I><FONT COLOR="#B22222">// future Gmsh sessions, use the 'Options-&gt;Save options now' menu.
</FONT></I></PRE>
<HR>
<A NAME="file5">
<H1>t4.geo 5/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 4
 * 
 *  Built-in functions, Holes
 *
 *********************************************************************/</FONT></I>

cm = 1e-02 ;

e1 = 4.5*cm ; e2 = 6*cm / 2 ; e3 =  5*cm / 2 ;

h1 = 5*cm ; h2 = 10*cm ; h3 = 5*cm ; h4 = 2*cm ; h5 = 4.5*cm ;

R1 = 1*cm ; R2 = 1.5*cm ; r = 1*cm ;

ccos = ( -h5*R1 + e2 * Hypot(h5,Hypot(e2,R1)) ) / (h5^2 + e2^2) ;
ssin = Sqrt(1-ccos^2) ;

Lc1 = 0.01 ;
Lc2 = 0.003 ;

<I><FONT COLOR="#B22222">// A whole set of operators can be used, which can be combined in all
</FONT></I><I><FONT COLOR="#B22222">// the expressions. These operators are defined in a similar way to
</FONT></I><I><FONT COLOR="#B22222">// their C or C++ equivalents (with the exception of '^'):
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   '-' (in both unary and binary versions, i.e. as in '-1' and '1-2')
</FONT></I><I><FONT COLOR="#B22222">//   '!' (the negation)
</FONT></I><I><FONT COLOR="#B22222">//   '+'
</FONT></I><I><FONT COLOR="#B22222">//   '*'
</FONT></I><I><FONT COLOR="#B22222">//   '/'
</FONT></I><I><FONT COLOR="#B22222">//   '%' (the rest of the integer division)
</FONT></I><I><FONT COLOR="#B22222">//   '&lt;'
</FONT></I><I><FONT COLOR="#B22222">//   '&gt;'
</FONT></I><I><FONT COLOR="#B22222">//   '&lt;='
</FONT></I><I><FONT COLOR="#B22222">//   '&gt;='
</FONT></I><I><FONT COLOR="#B22222">//   '=='
</FONT></I><I><FONT COLOR="#B22222">//   '!='
</FONT></I><I><FONT COLOR="#B22222">//   '&amp;&amp;' (and)
</FONT></I><I><FONT COLOR="#B22222">//   '||' (or)
</FONT></I><I><FONT COLOR="#B22222">//   '||' (or)
</FONT></I><I><FONT COLOR="#B22222">//   '^' (power)
</FONT></I><I><FONT COLOR="#B22222">//   '?' ':' (the ternary operator)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Grouping is done, as usual, with parentheses.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// In addition to these operators, all C mathematical functions can
</FONT></I><I><FONT COLOR="#B22222">// also be used (note the first capital letter), i.e.
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">//   Exp(x)
</FONT></I><I><FONT COLOR="#B22222">//   Log(x)
</FONT></I><I><FONT COLOR="#B22222">//   Log10(x)
</FONT></I><I><FONT COLOR="#B22222">//   Sqrt(x)
</FONT></I><I><FONT COLOR="#B22222">//   Sin(x)
</FONT></I><I><FONT COLOR="#B22222">//   Asin(x)
</FONT></I><I><FONT COLOR="#B22222">//   Cos(x)
</FONT></I><I><FONT COLOR="#B22222">//   Acos(x)
</FONT></I><I><FONT COLOR="#B22222">//   Tan(x)
</FONT></I><I><FONT COLOR="#B22222">//   Atan(x)
</FONT></I><I><FONT COLOR="#B22222">//   Atan2(x,y)
</FONT></I><I><FONT COLOR="#B22222">//   Sinh(x)
</FONT></I><I><FONT COLOR="#B22222">//   Cosh(x)
</FONT></I><I><FONT COLOR="#B22222">//   Tanh(x)
</FONT></I><I><FONT COLOR="#B22222">//   Fabs(x)
</FONT></I><I><FONT COLOR="#B22222">//   Floor(x)
</FONT></I><I><FONT COLOR="#B22222">//   Ceil(x)
</FONT></I><I><FONT COLOR="#B22222">//   Fmod(x,y)
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">// as well as a series of other functions:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   Hypot(x,y)   computes Sqrt(x^2+y^2)
</FONT></I><I><FONT COLOR="#B22222">//   Rand(x)      generates a random number in [0,x]
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The only predefined constant in Gmsh is Pi.
</FONT></I>
Point(1) = { -e1-e2, 0.0  , 0.0 , Lc1};
Point(2) = { -e1-e2, h1   , 0.0 , Lc1};
Point(3) = { -e3-r , h1   , 0.0 , Lc2};
Point(4) = { -e3-r , h1+r , 0.0 , Lc2};
Point(5) = { -e3   , h1+r , 0.0 , Lc2};
Point(6) = { -e3   , h1+h2, 0.0 , Lc1};
Point(7) = {  e3   , h1+h2, 0.0 , Lc1};
Point(8) = {  e3   , h1+r , 0.0 , Lc2};
Point(9) = {  e3+r , h1+r , 0.0 , Lc2};
Point(10)= {  e3+r , h1   , 0.0 , Lc2};
Point(11)= {  e1+e2, h1   , 0.0 , Lc1};
Point(12)= {  e1+e2, 0.0  , 0.0 , Lc1};
Point(13)= {  e2   , 0.0  , 0.0 , Lc1};

Point(14)= {  R1 / ssin , h5+R1*ccos, 0.0 , Lc2};
Point(15)= {  0.0       , h5        , 0.0 , Lc2};
Point(16)= { -R1 / ssin , h5+R1*ccos, 0.0 , Lc2};
Point(17)= { -e2        , 0.0       , 0.0 , Lc1};

Point(18)= { -R2  , h1+h3   , 0.0 , Lc2};
Point(19)= { -R2  , h1+h3+h4, 0.0 , Lc2};
Point(20)= {  0.0 , h1+h3+h4, 0.0 , Lc2};
Point(21)= {  R2  , h1+h3+h4, 0.0 , Lc2};
Point(22)= {  R2  , h1+h3   , 0.0 , Lc2};
Point(23)= {  0.0 , h1+h3   , 0.0 , Lc2};

Point(24)= {  0 , h1+h3+h4+R2, 0.0 , Lc2};
Point(25)= {  0 , h1+h3-R2,    0.0 , Lc2};

Line(1)  = {1 ,17};
Line(2)  = {17,16};

<I><FONT COLOR="#B22222">// All curves are not straight lines... Circles are defined by a list
</FONT></I><I><FONT COLOR="#B22222">// of three point numbers, which represent the starting point, the
</FONT></I><I><FONT COLOR="#B22222">// center and the end point, respectively. All circles have to be
</FONT></I><I><FONT COLOR="#B22222">// defined in the trigonometric (counter-clockwise) sense.  Note that
</FONT></I><I><FONT COLOR="#B22222">// the 3 points should not be aligned (otherwise the plane in which
</FONT></I><I><FONT COLOR="#B22222">// the circle lies has to be defined, by 'Circle(num) =
</FONT></I><I><FONT COLOR="#B22222">// {start,center,end} Plane {nx,ny,nz}').
</FONT></I>
Circle(3) = {14,15,16};
Line(4)  = {14,13};
Line(5)  = {13,12};
Line(6)  = {12,11};
Line(7)  = {11,10};
Circle(8) = { 8, 9,10};
Line(9)  = { 8, 7};
Line(10) = { 7, 6};
Line(11) = { 6, 5};
Circle(12) = { 3, 4, 5};
Line(13) = { 3, 2};
Line(14) = { 2, 1};
Line(15) = {18,19};
Circle(16) = {21,20,24};
Circle(17) = {24,20,19};
Circle(18) = {18,23,25};
Circle(19) = {25,23,22};
Line(20) = {21,22};

Line Loop(21) = {17,-15,18,19,-20,16};
Plane Surface(22) = {21};

<I><FONT COLOR="#B22222">// The surface is made of two line loops, i.e. it has one hole:
</FONT></I>
Line Loop(23) = {11,-12,13,14,1,2,-3,4,5,6,7,-8,9,10};
Plane Surface(24) = {23,21};

Physical Surface(1) = {22};
Physical Surface(2) = {24};
</PRE>
<HR>
<A NAME="file6">
<H1>t5.geo 6/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 5
 * 
 *  Characteristic lengths, Arrays of variables, Functions, Loops
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// This defines some characteristic lengths:
</FONT></I>
lcar1 = .1;
lcar2 = .0005;
lcar3 = .075;

<I><FONT COLOR="#B22222">// In order to change these lengths globally (without changing the
</FONT></I><I><FONT COLOR="#B22222">// file), a global scaling factor for all characteristic lengths can
</FONT></I><I><FONT COLOR="#B22222">// be specified on the command line with the option '-clscale' (or
</FONT></I><I><FONT COLOR="#B22222">// with the option Mesh.CharacteristicLengthFactor). For example,
</FONT></I><I><FONT COLOR="#B22222">// with:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// &gt; gmsh t5 -clscale 1
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// this example produces a mesh of approximately 2000 nodes and
</FONT></I><I><FONT COLOR="#B22222">// 10,000 tetrahedra (in 3 seconds on an alpha workstation running at
</FONT></I><I><FONT COLOR="#B22222">// 666MHz). With 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// &gt; gmsh t5 -clscale 0.2
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// (i.e. with all characteristic lengths divided by 5), the mesh
</FONT></I><I><FONT COLOR="#B22222">// counts approximately 170,000 nodes and one million tetrahedra
</FONT></I><I><FONT COLOR="#B22222">// (and the computation takes 16 minutes on the same machine :-( So
</FONT></I><I><FONT COLOR="#B22222">// there is still a lot of work to do to achieve decent performance
</FONT></I><I><FONT COLOR="#B22222">// with Gmsh...)
</FONT></I>
Point(1) = {0.5,0.5,0.5,lcar2}; Point(2) = {0.5,0.5,0,lcar1};
Point(3) = {0,0.5,0.5,lcar1};   Point(4) = {0,0,0.5,lcar1}; 
Point(5) = {0.5,0,0.5,lcar1};   Point(6) = {0.5,0,0,lcar1};
Point(7) = {0,0.5,0,lcar1};     Point(8) = {0,1,0,lcar1};
Point(9) = {1,1,0,lcar1};       Point(10) = {0,0,1,lcar1};
Point(11) = {0,1,1,lcar1};      Point(12) = {1,1,1,lcar1};
Point(13) = {1,0,1,lcar1};      Point(14) = {1,0,0,lcar1};

Line(1) = {8,9};    Line(2) = {9,12};  Line(3) = {12,11};
Line(4) = {11,8};   Line(5) = {9,14};  Line(6) = {14,13};
Line(7) = {13,12};  Line(8) = {11,10}; Line(9) = {10,13};
Line(10) = {10,4};  Line(11) = {4,5};  Line(12) = {5,6};
Line(13) = {6,2};   Line(14) = {2,1};  Line(15) = {1,3};
Line(16) = {3,7};   Line(17) = {7,2};  Line(18) = {3,4};
Line(19) = {5,1};   Line(20) = {7,8};  Line(21) = {6,14};

Line Loop(22) = {11,19,15,18};       Plane Surface(23) = {22};
Line Loop(24) = {16,17,14,15};       Plane Surface(25) = {24};
Line Loop(26) = {-17,20,1,5,-21,13}; Plane Surface(27) = {26};
Line Loop(28) = {4,1,2,3};           Plane Surface(29) = {28};
Line Loop(30) = {7,-2,5,6};          Plane Surface(31) = {30};
Line Loop(32) = {6,-9,10,11,12,21};  Plane Surface(33) = {32};
Line Loop(34) = {7,3,8,9};           Plane Surface(35) = {34};
Line Loop(36) = {10,-18,16,20,-4,8}; Plane Surface(37) = {36};
Line Loop(38) = {-14,-13,-12,19};    Plane Surface(39) = {38};

<I><FONT COLOR="#B22222">// Instead of using included files, one can also define functions. In
</FONT></I><I><FONT COLOR="#B22222">// the following function, the reserved variable 'newp' is used, which
</FONT></I><I><FONT COLOR="#B22222">// automatically selects a new point number. This number is chosen as
</FONT></I><I><FONT COLOR="#B22222">// the highest current point number, plus one. Analogously to 'newp',
</FONT></I><I><FONT COLOR="#B22222">// there exists a variable 'newreg' which selects the highest number
</FONT></I><I><FONT COLOR="#B22222">// of all entities other than points, plus one.
</FONT></I>
<I><FONT COLOR="#B22222">// Note: there are no local variables. This will be changed in a
</FONT></I><I><FONT COLOR="#B22222">// future version of Gmsh.
</FONT></I>
Function CheeseHole 

  p1 = newp; Point(p1) = {x,  y,  z,  lcar3} ;
  p2 = newp; Point(p2) = {x+r,y,  z,  lcar3} ;
  p3 = newp; Point(p3) = {x,  y+r,z,  lcar3} ;
  p4 = newp; Point(p4) = {x,  y,  z+r,lcar3} ;
  p5 = newp; Point(p5) = {x-r,y,  z,  lcar3} ;
  p6 = newp; Point(p6) = {x,  y-r,z,  lcar3} ;
  p7 = newp; Point(p7) = {x,  y,  z-r,lcar3} ;

  c1 = newreg; Circle(c1) = {p2,p1,p7};
  c2 = newreg; Circle(c2) = {p7,p1,p5};
  c3 = newreg; Circle(c3) = {p5,p1,p4};
  c4 = newreg; Circle(c4) = {p4,p1,p2};
  c5 = newreg; Circle(c5) = {p2,p1,p3};
  c6 = newreg; Circle(c6) = {p3,p1,p5};
  c7 = newreg; Circle(c7) = {p5,p1,p6};
  c8 = newreg; Circle(c8) = {p6,p1,p2};
  c9 = newreg; Circle(c9) = {p7,p1,p3};
  c10 = newreg; Circle(c10) = {p3,p1,p4};
  c11 = newreg; Circle(c11) = {p4,p1,p6};
  c12 = newreg; Circle(c12) = {p6,p1,p7};

<I><FONT COLOR="#B22222">// All surfaces are not plane... Here is the way to define ruled
</FONT></I><I><FONT COLOR="#B22222">// surfaces (which have 3 or 4 borders):
</FONT></I>
  l1 = newreg; Line Loop(l1) = {c5,c10,c4};   Ruled Surface(newreg) = {l1};
  l2 = newreg; Line Loop(l2) = {c9,-c5,c1};   Ruled Surface(newreg) = {l2};
  l3 = newreg; Line Loop(l3) = {-c12,c8,c1};  Ruled Surface(newreg) = {l3};
  l4 = newreg; Line Loop(l4) = {c8,-c4,c11};  Ruled Surface(newreg) = {l4};
  l5 = newreg; Line Loop(l5) = {-c10,c6,c3};  Ruled Surface(newreg) = {l5};
  l6 = newreg; Line Loop(l6) = {-c11,-c3,c7}; Ruled Surface(newreg) = {l6};
  l7 = newreg; Line Loop(l7) = {c2,c7,c12};   Ruled Surface(newreg) = {l7};
  l8 = newreg; Line Loop(l8) = {-c6,-c9,c2};  Ruled Surface(newreg) = {l8};

<I><FONT COLOR="#B22222">// Warning: surface meshes are generated by projecting a 2D mesh in
</FONT></I><I><FONT COLOR="#B22222">// the mean plane of the surface. This gives nice results only if the
</FONT></I><I><FONT COLOR="#B22222">// surface curvature is small enough. Otherwise you will have to cut
</FONT></I><I><FONT COLOR="#B22222">// the surface in pieces.
</FONT></I>
<I><FONT COLOR="#B22222">// Arrays of variables can be manipulated in the same way as classical
</FONT></I><I><FONT COLOR="#B22222">// variables. Warning: accessing an uninitialized element in an array
</FONT></I><I><FONT COLOR="#B22222">// will produce an unpredictable result. Note that whole arrays can
</FONT></I><I><FONT COLOR="#B22222">// also be instantly initialized (e.g. l[]={1,2,7} is valid).
</FONT></I>
  theloops[t] = newreg ; 

  Surface Loop(theloops[t]) = {l8+1, l5+1, l1+1, l2+1, -(l3+1), -(l7+1), l6+1, l4+1};

  thehole = newreg ; 
  Volume(thehole) = theloops[t] ;

Return


x = 0 ; y = 0.75 ; z = 0 ; r = 0.09 ;

<I><FONT COLOR="#B22222">// A For loop is used to generate five holes in the cube:
</FONT></I>
For t In {1:5}

  x += 0.166 ; 
  z += 0.166 ; 

<I><FONT COLOR="#B22222">// This command calls the function CheeseHole. Note that, instead of
</FONT></I><I><FONT COLOR="#B22222">// defining a function, we could have defined a file containing the
</FONT></I><I><FONT COLOR="#B22222">// same code, and used the Include command to include this file.
</FONT></I>
  Call CheeseHole ;

<I><FONT COLOR="#B22222">// A physical volume is defined for each cheese hole
</FONT></I>
  Physical Volume (t) = thehole ;
 
<I><FONT COLOR="#B22222">// The Printf function permits to print the value of variables on the
</FONT></I><I><FONT COLOR="#B22222">// terminal, in a way similar to the 'printf' C function:
</FONT></I>
  Printf(&quot;The cheese hole %g (center = {%g,%g,%g}, radius = %g) has number %g!&quot;,
	 t, x, y, z, r, thehole) ;

<I><FONT COLOR="#B22222">// Note: All Gmsh variables are treated internally as double precision
</FONT></I><I><FONT COLOR="#B22222">// numbers. The format string should thus only contain valid double
</FONT></I><I><FONT COLOR="#B22222">// precision number format specifiers (see the C or C++ language
</FONT></I><I><FONT COLOR="#B22222">// reference for more details).
</FONT></I>
EndFor

<I><FONT COLOR="#B22222">// This is the surface loop for the exterior surface of the cube:
</FONT></I>
theloops[0] = newreg ;

Surface Loop(theloops[0]) = {35,31,29,37,33,23,39,25,27} ;

<I><FONT COLOR="#B22222">// The volume of the cube, without the 5 cheese holes, is defined by 6
</FONT></I><I><FONT COLOR="#B22222">// surface loops (the exterior surface and the five interior loops).
</FONT></I><I><FONT COLOR="#B22222">// To reference an array of variables, its identifier is followed by
</FONT></I><I><FONT COLOR="#B22222">// '[]':
</FONT></I>
Volume(186) = {theloops[]} ;

<I><FONT COLOR="#B22222">// This physical volume assigns the region number 10 to the tetrahedra
</FONT></I><I><FONT COLOR="#B22222">// paving the cube (but not the holes, whose elements were tagged from
</FONT></I><I><FONT COLOR="#B22222">// 1 to 5 in the 'For' loop)
</FONT></I>
Physical Volume (10) = 186 ;

</PRE>
<HR>
<A NAME="file7">
<H1>t6.geo 7/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 6
 * 
 *  Transfinite meshes
 *
 *********************************************************************/</FONT></I>

r_int  = 0.05 ;
r_ext  = 0.051 ;
r_far  = 0.125 ;
r_inf  = 0.4 ;
phi1   = 30. * (Pi/180.) ;
angl   = 45. * (Pi/180.) ;

nbpt_phi   = 5 ; nbpt_int   = 20 ;
nbpt_arc1  = 10 ; nbpt_arc2  = 10 ;
nbpt_shell = 10 ; nbpt_far   = 25 ; nbpt_inf = 15 ;

lc0 = 0.1 ; lc1 = 0.1 ; lc2 = 0.3 ;

Point(1) = {0,     0, 0, lc0} ;
Point(2) = {r_int, 0, 0, lc0} ;
Point(3) = {r_ext, 0, 0, lc1} ;
Point(4) = {r_far, 0, 0, lc2} ;
Point(5) = {r_inf, 0, 0, lc2} ;
Point(6) = {0, 0,  r_int, lc0} ;
Point(7) = {0, 0,  r_ext, lc1} ;
Point(8) = {0, 0,  r_far, lc2} ;
Point(9) = {0, 0,  r_inf, lc2} ;

Point(10) = {r_int*Cos(phi1), r_int*Sin(phi1), 0, lc0} ;
Point(11) = {r_ext*Cos(phi1), r_ext*Sin(phi1), 0, lc1} ;
Point(12) = {r_far*Cos(phi1), r_far*Sin(phi1), 0, lc2} ;
Point(13) = {r_inf*Cos(phi1), r_inf*Sin(phi1), 0, lc2} ;

Point(14) = {r_int/2,           0,   0,               lc2} ;
Point(15) = {r_int/2*Cos(phi1), r_int/2*Sin(phi1), 0, lc2} ;
Point(16) = {r_int/2,           0,                 r_int/2, lc2} ;
Point(17) = {r_int/2*Cos(phi1), r_int/2*Sin(phi1), r_int/2, lc2} ;
Point(18) = {0, 0,  r_int/2, lc2} ;
Point(19) = {r_int*Cos(angl),           0,                         r_int*Sin(angl), lc2} ;
Point(20) = {r_int*Cos(angl)*Cos(phi1), r_int*Cos(angl)*Sin(phi1), r_int*Sin(angl), lc2} ;
Point(21) = {r_ext*Cos(angl),           0,                         r_ext*Sin(angl), lc2} ;
Point(22) = {r_ext*Cos(angl)*Cos(phi1), r_ext*Cos(angl)*Sin(phi1), r_ext*Sin(angl), lc2} ;
Point(23) = {r_far*Cos(angl),           0,                         r_far*Sin(angl), lc2} ;
Point(24) = {r_far*Cos(angl)*Cos(phi1), r_far*Cos(angl)*Sin(phi1), r_far*Sin(angl), lc2} ;
Point(25) = {r_inf,           0,                r_inf, lc2} ;
Point(26) = {r_inf*Cos(phi1), r_inf*Sin(phi1),  r_inf, lc2} ;

Circle(1) = {2,1,19};   Circle(2) = {19,1,6};   Circle(3) = {3,1,21};
Circle(4) = {21,1,7};   Circle(5) = {4,1,23};   Circle(6) = {23,1,8};   
Line(7) = {5,25};   Line(8) = {25,9};
Circle(9) = {10,1,20};  Circle(10) = {20,1,6};  Circle(11) = {11,1,22};
Circle(12) = {22,1,7};  Circle(13) = {12,1,24}; Circle(14) = {24,1,8};
Line(15) = {13,26}; Line(16) = {26,9};
Circle(17) = {19,1,20}; Circle(18) = {21,1,22}; Circle(19) = {23,1,24};
Circle(20) = {25,1,26}; Circle(21) = {2,1,10};  Circle(22) = {3,1,11};  
Circle(23) = {4,1,12};  Circle(24) = {5,1,13};

Line(25) = {1,14};  Line(26) = {14,2};  Line(27) = {2,3};   Line(28) = {3,4};
Line(29) = {4,5};   Line(30) = {1,15};  Line(31) = {15,10}; Line(32) = {10,11};
Line(33) = {11,12}; Line(34) = {12,13}; Line(35) = {14,15}; Line(36) = {14,16};
Line(37) = {15,17}; Line(38) = {16,17}; Line(39) = {18,16}; Line(40) = {18,17};
Line(41) = {1,18};  Line(42) = {18,6};  Line(43) = {6,7};   Line(44) = {16,19};
Line(45) = {19,21}; Line(46) = {21,23}; Line(47) = {23,25}; Line(48) = {17,20};
Line(49) = {20,22}; Line(50) = {22,24}; Line(51) = {24,26}; Line(52) = {7,8};
Line(53) = {8,9};

Line Loop(54) = {39,-36,-25,41};  Ruled Surface(55) = {54};
Line Loop(56) = {44,-1,-26,36};   Ruled Surface(57) = {56};
Line Loop(58) = {3,-45,-1,27};    Ruled Surface(59) = {58};
Line Loop(60) = {5,-46,-3,28};    Ruled Surface(61) = {60};
Line Loop(62) = {7,-47,-5,29};    Ruled Surface(63) = {62};
Line Loop(64) = {-2,-44,-39,42};  Ruled Surface(65) = {64};
Line Loop(66) = {-4,-45,2,43};    Ruled Surface(67) = {66};
Line Loop(68) = {-6,-46,4,52};    Ruled Surface(69) = {68};
Line Loop(70) = {-8,-47,6,53};    Ruled Surface(71) = {70};
Line Loop(72) = {-40,-41,30,37};  Ruled Surface(73) = {72};
Line Loop(74) = {48,-9,-31,37};   Ruled Surface(75) = {74};
Line Loop(76) = {49,-11,-32,9};   Ruled Surface(77) = {76};
Line Loop(78) = {-50,-11,33,13};  Ruled Surface(79) = {78};
Line Loop(80) = {-51,-13,34,15};  Ruled Surface(81) = {80};
Line Loop(82) = {10,-42,40,48};   Ruled Surface(83) = {82};
Line Loop(84) = {12,-43,-10,49};  Ruled Surface(85) = {84};
Line Loop(86) = {14,-52,-12,50};  Ruled Surface(87) = {86};
Line Loop(88) = {16,-53,-14,51};  Ruled Surface(89) = {88};
Line Loop(90) = {-30,25,35};      Ruled Surface(91) = {90};
Line Loop(92) = {-40,39,38};      Ruled Surface(93) = {92};
Line Loop(94) = {37,-38,-36,35};  Ruled Surface(95) = {94};
Line Loop(96) = {-48,-38,44,17};  Ruled Surface(97) = {96};
Line Loop(98) = {18,-49,-17,45};  Ruled Surface(99) = {98};
Line Loop(100) = {19,-50,-18,46}; Ruled Surface(101) = {100};
Line Loop(102) = {20,-51,-19,47}; Ruled Surface(103) = {102};
Line Loop(104) = {-2,17,10};      Ruled Surface(105) = {104};
Line Loop(106) = {-9,-21,1,17};   Ruled Surface(107) = {106};
Line Loop(108) = {-4,18,12};      Ruled Surface(109) = {108};
Line Loop(110) = {-11,-22,3,18};  Ruled Surface(111) = {110};
Line Loop(112) = {-13,-23,5,19};  Ruled Surface(113) = {112};
Line Loop(114) = {-6,19,14};      Ruled Surface(115) = {114};
Line Loop(116) = {-15,-24,7,20};  Ruled Surface(117) = {116};
Line Loop(118) = {-8,20,16};      Ruled Surface(119) = {118};
Line Loop(120) = {-31,-35,26,21}; Ruled Surface(121) = {120};
Line Loop(122) = {32,-22,-27,21}; Ruled Surface(123) = {122};
Line Loop(124) = {33,-23,-28,22}; Ruled Surface(125) = {124};
Line Loop(126) = {34,-24,-29,23}; Ruled Surface(127) = {126};

Surface Loop(128) = {93,-73,-55,95,-91};         Volume(129) = {128}; <I><FONT COLOR="#B22222">// int
</FONT></I>Surface Loop(130) = {107,-75,-97,95,57,121};     Volume(131) = {130}; <I><FONT COLOR="#B22222">// int b
</FONT></I>Surface Loop(132) = {105,-65,-97,-83,-93};       Volume(133) = {132}; <I><FONT COLOR="#B22222">// int h
</FONT></I>Surface Loop(134) = {99,-111,77,123,59,107};     Volume(135) = {134}; <I><FONT COLOR="#B22222">// shell b
</FONT></I>Surface Loop(136) = {99,-109,67,105,85};         Volume(137) = {136}; <I><FONT COLOR="#B22222">// shell h
</FONT></I>Surface Loop(138) = {113,79,-101,-111,-125,-61}; Volume(139) = {138}; <I><FONT COLOR="#B22222">// ext b
</FONT></I>Surface Loop(140) = {115,-69,-101,-87,-109};     Volume(141) = {140}; <I><FONT COLOR="#B22222">// ext h
</FONT></I>Surface Loop(142) = {103,-117,-81,113,127,63};   Volume(143) = {142}; <I><FONT COLOR="#B22222">// inf b
</FONT></I>Surface Loop(144) = {89,-119,71,103,115};        Volume(145) = {144}; <I><FONT COLOR="#B22222">// inf h
</FONT></I>
<I><FONT COLOR="#B22222">// Transfinite line commands explicitly specify the number of points
</FONT></I><I><FONT COLOR="#B22222">// and their distribution. 'Progression 2' means that each line
</FONT></I><I><FONT COLOR="#B22222">// element in the series will be twice as long as the preceding one.
</FONT></I>
Transfinite Line{35,21,22,23,24,38,17,18,19,20}   = nbpt_phi ;
Transfinite Line{31,26,48,44,42}                  = nbpt_int Using Progression 0.88;
Transfinite Line{41,37,36,9,11,1,3,13,5,15,7}     = nbpt_arc1 ;
Transfinite Line{30,25,40,39,10,2,12,4,14,6,16,8} = nbpt_arc2 ;
Transfinite Line{32,27,49,45,43}                  = nbpt_shell ;
Transfinite Line{33,28,46,50,52}                  = nbpt_far Using Progression 1.2 ;
Transfinite Line{34,29,51,47,53}                  = nbpt_inf Using Progression 1.05;

<I><FONT COLOR="#B22222">// *All* 2D and 3D transfinite entities are defined in respect to
</FONT></I><I><FONT COLOR="#B22222">// points. The ordering of the points defines the ordering of the mesh
</FONT></I><I><FONT COLOR="#B22222">// elements.
</FONT></I>
Transfinite Surface{55} = {1,14,16,18};
Transfinite Surface{57} = {14,2,19,16};
Transfinite Surface{59} = {2,3,21,19};
Transfinite Surface{61} = {3,4,23,21};
Transfinite Surface{63} = {4,5,25,23};
Transfinite Surface{73} = {1,15,17,18};
Transfinite Surface{75} = {15,10,20,17};
Transfinite Surface{77} = {10,11,22,20};
Transfinite Surface{79} = {11,12,24,22};
Transfinite Surface{81} = {12,13,26,24};
Transfinite Surface{65} = {18,16,19,6};
Transfinite Surface{67} = {6,19,21,7};
Transfinite Surface{69} = {7,21,23,8};
Transfinite Surface{71} = {8,23,25,9};
Transfinite Surface{83} = {17,18,6,20};
Transfinite Surface{85} = {20,6,7,22};
Transfinite Surface{87} = {22,7,8,24};
Transfinite Surface{89} = {24,8,9,26};
Transfinite Surface{91} = {1,14,15};
Transfinite Surface{95} = {15,14,16,17};
Transfinite Surface{93} = {18,16,17};
Transfinite Surface{121} = {15,14,2,10};
Transfinite Surface{97} = {17,16,19,20};
Transfinite Surface{123} = {10,2,3,11};
Transfinite Surface{99} = {20,19,21,22};
Transfinite Surface{107} = {10,2,19,20};
Transfinite Surface{105} = {6,20,19};
Transfinite Surface{109} = {7,22,21};
Transfinite Surface{111} = {11,3,21,22};
Transfinite Surface{101} = {22,21,23,24};
Transfinite Surface{125} = {11,3,4,12};
Transfinite Surface{115} = {8,24,23};
Transfinite Surface{113} = {24,12,4,23};
Transfinite Surface{127} = {12,13,5,4};
Transfinite Surface{103} = {24,23,25,26};
Transfinite Surface{119} = {9,26,25};
Transfinite Surface{117} = {13,5,25,26};

<I><FONT COLOR="#B22222">// As with Extruded meshes, the Recombine command tells Gmsh to
</FONT></I><I><FONT COLOR="#B22222">// recombine the simplices into quadrangles, prisms or hexahedra when
</FONT></I><I><FONT COLOR="#B22222">// possible. A colon in a list acts as in the 'For' loop: all surfaces
</FONT></I><I><FONT COLOR="#B22222">// having numbers between 55 and 127 are considered.
</FONT></I>
Recombine Surface {55:127};

<I><FONT COLOR="#B22222">// *All* 2D and 3D transfinite entities are defined in respect to
</FONT></I><I><FONT COLOR="#B22222">// points. The ordering of the points defines the ordering of the mesh
</FONT></I><I><FONT COLOR="#B22222">// elements.
</FONT></I>
Transfinite Volume{129} = {1,14,15,18,16,17};
Transfinite Volume{131} = {17,16,14,15,20,19,2,10};
Transfinite Volume{133} = {18,17,16,6,20,19};
Transfinite Volume{135} = {10,2,19,20,11,3,21,22};
Transfinite Volume{137} = {6,20,19,7,22,21};
Transfinite Volume{139} = {11,3,4,12,22,21,23,24};
Transfinite Volume{141} = {7,22,21,8,24,23};
Transfinite Volume{143} = {12,4,5,13,24,23,25,26};
Transfinite Volume{145} = {8,24,23,9,26,25};

VolInt           = 1000 ;
SurfIntPhi0      = 1001 ;
SurfIntPhi1      = 1002 ;
SurfIntZ0        = 1003 ;

VolShell         = 2000 ;
SurfShellInt     = 2001 ;
SurfShellExt     = 2002 ;
SurfShellPhi0    = 2003 ;
SurfShellPhi1    = 2004 ;
SurfShellZ0      = 2005 ;
LineShellIntPhi0 = 2006 ;
LineShellIntPhi1 = 2007 ;
LineShellIntZ0   = 2008 ;
PointShellInt    = 2009 ;

VolExt           = 3000 ;
VolInf           = 3001 ;
SurfInf          = 3002 ;
SurfExtInfPhi0   = 3003 ;
SurfExtInfPhi1   = 3004 ;
SurfExtInfZ0     = 3005 ;
SurfInfRight     = 3006 ;
SurfInfTop       = 3007 ;

Physical Volume  (VolInt)           = {129,131,133} ;
Physical Surface (SurfIntPhi0)      = {55,57,65} ;
Physical Surface (SurfIntPhi1)      = {73,75,83} ;
Physical Surface (SurfIntZ0)        = {91,121} ;

Physical Volume  (VolShell)         = {135,137} ;
Physical Surface (SurfShellInt)     = {105,107} ;
Physical Surface (SurfShellExt)     = {109,111} ;
Physical Surface (SurfShellPhi0)    = {59,67} ;
Physical Surface (SurfShellPhi1)    = {77,85} ;
Physical Surface (SurfShellZ0)      = {123} ;
Physical Line    (LineShellIntPhi0) = {1,2} ;
Physical Line    (LineShellIntPhi1) = {9,10} ;
Physical Line    (LineShellIntZ0)   = 21 ;
Physical Point   (PointShellInt)    = 6 ;

Physical Volume  (VolExt)           = {139,141} ;
Physical Volume  (VolInf)           = {143,145} ;
Physical Surface (SurfExtInfPhi0)   = {61,63,69,71} ;
Physical Surface (SurfExtInfPhi1)   = {79,87,81,89} ;
Physical Surface (SurfExtInfZ0)     = {125,127} ;
Physical Surface (SurfInfRight)     = {117} ;
Physical Surface (SurfInfTop)       = {119} ;
</PRE>
<HR>
<A NAME="file8">
<H1>t7.geo 8/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 7
 * 
 *  Anisotropic meshes, Attractors
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// The new anisotropic 2D mesh generator can be selected with:
</FONT></I>
Mesh.Algorithm = 2 ;

<I><FONT COLOR="#B22222">// One can force a 4 step Laplacian smoothing of the mesh with:
</FONT></I>
Mesh.Smoothing = 4 ;

lc = .1;

Point(1) = {0.0,0.0,0,lc};
Point(2) = {1.2,-0.2,0,lc};
Point(3) = {1,1,0,lc};
Point(4) = {0,1,0,lc};

Line(1) = {3,2};
Line(2) = {2,1};
Line(3) = {1,4};
Line(4) = {4,3};

Line Loop(5) = {1,2,3,4};
Plane Surface(6) = {5};

Point(5) = {0.1,0.2,0,lc};
Point(11) = {0.5,0.5,-1,lc};
Point(12) = {0.5,0.5,0,lc};
Point(22) = {0.6,0.6,1,lc};

Line(5) = {11,22};

Spline(7) = {4,5,12,2};

<I><FONT COLOR="#B22222">// Anisotropic attractors can be defined on points and lines:
</FONT></I>
Attractor Line{5} = {.1, 0.01, 17};

Attractor Line{1,2} = {0.1, 0.005, 3};
Attractor Line{7} = {0.1, 0.05, 3};

</PRE>
<HR>
<A NAME="file9">
<H1>t8.geo 9/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 8
 * 
 *  Post-Processing, Scripting, Animations, Options
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// The first example is included, as well as some post-processing maps
</FONT></I><I><FONT COLOR="#B22222">// (for the format of the post-processing maps, see the FORMATS file):
</FONT></I>
Include &quot;t1.geo&quot; ;
Include &quot;view1.pos&quot; ;
Include &quot;view1.pos&quot; ;
Include &quot;view4.pos&quot; ;

<I><FONT COLOR="#B22222">// Some general options are set (all the options specified
</FONT></I><I><FONT COLOR="#B22222">// interactively can be directly specified in the ascii input
</FONT></I><I><FONT COLOR="#B22222">// files. The current options can be saved into a file by selecting
</FONT></I><I><FONT COLOR="#B22222">// 'File-&gt;Save as-&gt;Gmsh options').
</FONT></I>
General.Trackball = 0 ;
General.RotationX = 0 ;
General.RotationY = 0 ;
General.RotationZ = 0 ;
General.Color.Background = White ;
General.Color.Foreground = Black ;
General.Color.Text = Black ;
General.Orthographic = 0 ;
General.Axes = 0 ;
General.SmallAxes = 0 ;

<I><FONT COLOR="#B22222">// Some options are also specified for each post-processing view:
</FONT></I>
View[0].IntervalsType = 2 ;
View[0].OffsetZ = 0.05 ;
View[0].RaiseZ = 0 ;
View[0].Light = 1 ;
View[0].ShowScale = 0;
View[0].SmoothNormals = 1;

View[1].IntervalsType = 1 ;
View[1].ColorTable = { Green, Blue } ;
View[1].NbIso = 10 ;
View[1].ShowScale = 0;

View[2].Name = &quot;Test...&quot; ;
View[2].IntervalsType = 2 ;
View[2].Type = 2;
View[2].IntervalsType = 2 ;
View[2].AutoPosition = 0;
View[2].PositionX = 85;
View[2].PositionY = 50;
View[2].Width = 200;
View[2].Height = 150;

View[3].Type = 3;
View[3].RangeType = 2;
View[3].IntervalsType = 4 ;
View[3].ShowScale = 0;
View[3].Grid = 0;
View[3].CustomMin = View[2].CustomMin;
View[3].CustomMax = View[2].CustomMax;
View[3].AutoPosition = 0;
View[3].PositionX = View[2].PositionX;
View[3].PositionY = View[2].PositionY;
View[3].Width = View[2].Width;
View[3].Height = View[2].Height;

<I><FONT COLOR="#B22222">// We loop from 1 to 255 with a step of 1 (to use a step different
</FONT></I><I><FONT COLOR="#B22222">// from 1, just add a third argument in the list. For example, 'For
</FONT></I><I><FONT COLOR="#B22222">// num In {0.5:1.5:0.1}' would increment num from 0.5 to 1.5 with a
</FONT></I><I><FONT COLOR="#B22222">// step of 0.1).
</FONT></I>
t = 0 ;

For num In {1:255}

  View[0].TimeStep = t ;
  View[1].TimeStep = t ;
  View[2].TimeStep = t ;
  View[3].TimeStep = t ;

  t = (View[0].TimeStep &lt; View[0].NbTimeStep-1) ? t+1 : 0 ;
  
  View[0].RaiseZ += 0.01*t ;

  If (num == 3)
    <I><FONT COLOR="#B22222">// We want to create 320x240 frames when num==3:
</FONT></I>    General.GraphicsWidth = 320 ; 
    General.GraphicsHeight = 240 ;
  EndIf

  <I><FONT COLOR="#B22222">// It is possible to nest loops:
</FONT></I>  For num2 In {1:50}

    General.RotationX += 10 ;
    General.RotationY = General.RotationX / 3 ;
    General.RotationZ += 0.1 ;
 
    Sleep 0.01; <I><FONT COLOR="#B22222">// sleep for 0.01 second
</FONT></I>    Draw; <I><FONT COLOR="#B22222">// draw the scene
</FONT></I>
    If ((num == 3) &amp;&amp; (num2 &lt; 10))
      <I><FONT COLOR="#B22222">// The Sprintf function permits to create complex strings using
</FONT></I>      <I><FONT COLOR="#B22222">// variables (since all Gmsh variables are treated internally as
</FONT></I>      <I><FONT COLOR="#B22222">// double precision numbers, the format should only contain valid
</FONT></I>      <I><FONT COLOR="#B22222">// double precision number format specifiers):
</FONT></I>      Print Sprintf(&quot;t8-0%g.gif&quot;, num2);
      Print Sprintf(&quot;t8-0%g.jpg&quot;, num2);
    EndIf

    If ((num == 3) &amp;&amp; (num2 &gt;= 10))
       Print Sprintf(&quot;t8-%g.gif&quot;, num2);
       Print Sprintf(&quot;t8-%g.jpg&quot;, num2);
    EndIf

  EndFor

  If(num == 3)
    <I><FONT COLOR="#B22222">// We could make a system call to generate the mpeg (uncomment the
</FONT></I>    <I><FONT COLOR="#B22222">// following of mpeg_encode is installed on your computer)
</FONT></I>
    <I><FONT COLOR="#B22222">// System &quot;mpeg_encode t8.par&quot; ;
</FONT></I>  EndIf

EndFor


<I><FONT COLOR="#B22222">// Here is the list of available scripting commands:
</FONT></I><I><FONT COLOR="#B22222">//  
</FONT></I><I><FONT COLOR="#B22222">//  Merge string;     (to merge a file)
</FONT></I><I><FONT COLOR="#B22222">//  Draw;             (to draw the scene)
</FONT></I><I><FONT COLOR="#B22222">//  Mesh int;         (to perform the mesh generation; 'int' = 0, 1, 2 or 3)
</FONT></I><I><FONT COLOR="#B22222">//  Save string;      (to save the mesh)
</FONT></I><I><FONT COLOR="#B22222">//  Print string;     (to print the graphic window)
</FONT></I><I><FONT COLOR="#B22222">//  Sleep expr;       (to sleep during expr seconds)
</FONT></I><I><FONT COLOR="#B22222">//  Delete View[int]; (to free the view int)
</FONT></I><I><FONT COLOR="#B22222">//  Delete Meshes;    (to free all meshes)
</FONT></I><I><FONT COLOR="#B22222">//  System string;    (to execute a system call)
</FONT></I></PRE>
<HR>
<A NAME="file10">
<H1>t9.geo 10/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 9
 * 
 *  Post-Processing, Plugins
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// Plugins can be added to Gmsh in order to extend its
</FONT></I><I><FONT COLOR="#B22222">// capabilities. For example, post-processing plugins can modify a
</FONT></I><I><FONT COLOR="#B22222">// view, or create a new view based on previously loaded
</FONT></I><I><FONT COLOR="#B22222">// views. Several default plugins are statically linked into Gmsh,
</FONT></I><I><FONT COLOR="#B22222">// e.g. CutMap, CutPlane, CutSphere, Skin, Transform or Smooth.
</FONT></I>
<I><FONT COLOR="#B22222">// Let's load a three-dimensional scalar view
</FONT></I>
Include &quot;view3.pos&quot; ;

<I><FONT COLOR="#B22222">// Plugins can be controlled in the same way as other options in
</FONT></I><I><FONT COLOR="#B22222">// Gmsh. For example, the CutMap plugin (which extracts an isovalue
</FONT></I><I><FONT COLOR="#B22222">// surface from a 3D scalar view) can either be called from the
</FONT></I><I><FONT COLOR="#B22222">// graphical interface (right click on the view button, then
</FONT></I><I><FONT COLOR="#B22222">// Plugins-&gt;CutMap), or from the command file:
</FONT></I>
Plugin(CutMap).A = 0.67 ; <I><FONT COLOR="#B22222">// iso-value level
</FONT></I>Plugin(CutMap).iView = 0 ; <I><FONT COLOR="#B22222">// source view is View[0]
</FONT></I>Plugin(CutMap).Run ; 

<I><FONT COLOR="#B22222">// The following runs the CutPlane plugin:
</FONT></I>
Plugin(CutPlane).A = 0 ; 
Plugin(CutPlane).B = 0.2 ; 
Plugin(CutPlane).C = 1 ; 
Plugin(CutPlane).D = 0 ; 
Plugin(CutPlane).Run ; 

View[0].Light = 1;
View[0].IntervalsType = 2;
View[0].NbIso = 6;
View[0].SmoothNormals = 1;

View[1].IntervalsType = 2;

View[2].IntervalsType = 2;
Draw;
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU enscript 1.6.1</A>.</ADDRESS>
</BODY>
</HTML>
